generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator zod {
  provider         = "zod-prisma-types"
  output           = "./zod"
  useMultipleFiles = true
  relationModel    = true
  generateClient   = true
}

model User {
  id            String     @id @default(cuid())
  name          String?
  email         String     @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  sessions      Session[]
  userRoles     UserRole[]
  Library       Library[] 
  sentNotifications     Notification[] @relation("SentNotifications")
  receivedNotifications Notification[] @relation("ReceivedNotifications")
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model RequestLog {
  id        String   @id // UUID or unique string per request
  createdAt DateTime @default(now())

  @@index([createdAt]) // optional, helps with cleanup queries
}

model Library {
  id        String   @id @default(cuid())
  name      String
  ownerId   String
  createdAt DateTime @default(now())

  owner     User       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  userRoles UserRole[]
  seats     Seat[] // Seats under this library
  members   Member[] // Members registered in this library
  shifts    Shift[] // Shifts configured by this library  
  notifications Notification[] 
  
}

model UserRole {
  id        String   @id @default(cuid())
  userId    String
  libraryId String
  role      RoleType

  user    User    @relation(fields: [userId], references: [id])
  library Library @relation(fields: [libraryId], references: [id], onDelete: Cascade)

  @@unique([userId, libraryId])
}

enum RoleType {
  ADMIN
  MANAGER
}

model Seat {
  id         String @id @default(cuid())
  seatNumber String
  libraryId  String

  library  Library   @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  bookings Booking[]
}

model Member {
  id        String   @id @default(cuid())
  name      String
  phone     String
  joinedAt  DateTime @default(now())
  libraryId String

  library  Library   @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  bookings Booking[] // Bookings made by this member
  payments Payment[] // Payments made by this member
}

model Shift {
  id        String @id @default(cuid())
  name      String // "Morning", "Evening", etc.
  startTime String // "08:00"
  endTime   String // "12:00"
  libraryId String

  library  Library   @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  bookings Booking[] // Bookings tied to this shift
}

model Booking {
  id       String   @id @default(cuid())
  seatId   String
  memberId String
  date     DateTime // Date of booking
  shiftId  String

  createdAt DateTime @default(now())

  seat   Seat   @relation(fields: [seatId], references: [id], onDelete: Cascade)
  member Member @relation(fields: [memberId], references: [id], onDelete: Cascade)
  shift  Shift  @relation(fields: [shiftId], references: [id], onDelete: Cascade)

  @@unique([seatId, shiftId]) // no double-booking for same slot 
  @@unique([memberId, seatId]) // no double seat by same member 
}

model Payment {
  id         String    @id @default(cuid())
  memberId   String
  startMonth String    // e.g. "2025-08"
  validTill  DateTime  // Calculate from startMonth + duration
  duration   Int       // In months (1, 3, 6, 12)
  amount     Float
  paid       Boolean   @default(false)
  paidAt     DateTime? // Null if unpaid
  createdAt  DateTime  @default(now())

  member Member @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@index([memberId, validTill])
}

model Notification {
  id          String       @id @default(cuid())
  type        NotificationType
  message     String       // Human readable text (optional)
  data        Json?        // Extra payload (e.g., memberId, shiftId, etc.)
  status      NotificationStatus @default(PENDING)
  
  // Relations
  senderId    String?
  receiverId  String
  libraryId   String?
  
  sender      User?        @relation("SentNotifications", fields: [senderId], references: [id])
  receiver    User         @relation("ReceivedNotifications", fields: [receiverId], references: [id])
  library     Library?     @relation(fields: [libraryId], references: [id]) 
  
  
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

enum NotificationType {
  INVITE_MANAGER
  MEMBER_ADDED
  MEMBER_UPDATED
  MEMBER_DELETED
  SHIFT_CHANGE_REQUEST
  SHIFT_CHANGE_RESPONSE
  PAYMENT_REMINDER
}

enum NotificationStatus {
  PENDING   // waiting for user action
  ACCEPTED  // user confirmed
  REJECTED  // user declined
  READ      // seen but no action required
}
